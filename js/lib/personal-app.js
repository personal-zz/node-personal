// Generated by CoffeeScript 1.4.0

/*

#Personal Node.js Library

MIT License
*/


(function() {
  var PersonalApp, PersonalClient, PersonalConnectOptions, PersonalHelpers, PersonalMiddleware, PersonalScope, connect_curr_req_url, crypto, http, https, mime, q, querystring, url, _BACKOFF_DELAY, _QPS_REGEX, _api_path_prefix, _code_regex, _http_req, _oauth_access_path, _oauth_proto, _oauth_req_path, _test_hostname, _test_port, _test_proto,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  q = require("q");

  url = require("url");

  mime = require("mime");

  http = require("http");

  https = require("https");

  crypto = require("crypto");

  querystring = require("querystring");

  _api_path_prefix = "/api/v1";

  _oauth_req_path = "/oauth/authorize";

  _oauth_access_path = "/oauth/access_token";

  _oauth_proto = "https";

  _test_proto = "http";

  _test_hostname = "127.0.0.1";

  _test_port = 7357;

  _BACKOFF_DELAY = 2000;

  _code_regex = /^[a-z0-9]{20}$/i;

  _code_regex.compile(_code_regex);

  _QPS_REGEX = /developer over qps/im;

  _QPS_REGEX.compile(_QPS_REGEX);

  _http_req = function(opts, proto_obj, data, res_enc, callback) {
    var deferred, req, _handle_err;
    deferred = q.defer();
    _handle_err = function(err) {
      if (callback != null) {
        callback(err);
      }
      return deferred.reject(err);
    };
    req = proto_obj.request(opts, function(res) {
      var json_res;
      if (res_enc != null) {
        res.setEncoding(res_enc);
      }
      json_res = "";
      res.on("data", function(chunk) {
        return json_res += chunk;
      });
      return res.on("end", function() {
        var return_obj;
        if (this.statusCode === 403 && _QPS_REGEX.test(json_res)) {
          return setTimeout(_http_req, _BACKOFF_DELAY, opts, proto_obj, res_enc, callback);
        }
        if (this.statusCode !== 200) {
          return _handle_err(new Error("status " + this.statusCode + "\t" + json_res));
        }
        try {
          return_obj = JSON.parse(json_res);
          if ((callback != null) && typeof callback === 'function') {
            callback(null, return_obj);
          }
          return deferred.resolve(return_obj);
        } catch (e) {
          return _handle_err(e);
        }
      });
    });
    req.on("error", function(e) {
      return _handle_err(e);
    });
    if (data != null) {
      req.write(data);
    }
    req.end();
    return deferred.promise;
  };

  PersonalApp = (function() {
    /*
        PersonalApp is intended for a stand-alone (non-web server) app.  Instantiate it to access the Personal API.
    */

    function PersonalApp(config) {
      /*
              PersonalApp constructor
              
                  config:
                      client_id: string - <client id> (required)
                      client_secret: string - <client secret> (required)
                      sandbox: boolean - use sandbox if true and production if false (default: false)
      */
      this._config = config;
      this._config.hostname = "" + (config.sandbox ? "api-sandbox" : "api") + ".personal.com";
    }

    PersonalApp.prototype.get_auth_request_url = function(options) {
      /*
              Get the URL for sending a user to the authorization page
      
                  options:
                      redirect_uri: string - The callback URL that the user will return to after authorization (required)
                      scope: PersonalScope - Object representing the scope for which you are requesting authorization (required)
                      update: boolean - specifies if the selection UI dialog should be presented even if the 3rd party already has access to the requested resource(default: true)
      
                  returns an object containing
                      url: string - a formatted URL string (same formatted output as url.format() - see http://nodejs.org/api/url.html) 
                      state: the state parameter in the redirect_uri
      */

      var redir_url, redir_url_obj, return_obj, state_param;
      state_param = crypto.randomBytes(32).toString('hex');
      redir_url_obj = url.parse(options.redirect_uri, true);
      redir_url_obj.search = void 0;
      redir_url_obj.query.state = state_param;
      redir_url = url.format(redir_url_obj);
      return return_obj = {
        state: state_param,
        redirect_uri: redir_url,
        url: url.format({
          hostname: this._config.hostname,
          protocol: _oauth_proto,
          pathname: _oauth_req_path,
          query: {
            client_id: this._config.client_id,
            response_type: "code",
            redirect_uri: redir_url,
            scope: options.scope.to_s(),
            update: (options.update === false ? false : true)
          }
        })
      };
    };

    PersonalApp.prototype.get_access_token_auth = function(args, callback) {
      /*
              Get the access token for Personal API access using authorization code flow
              
                  args:
                      code: string - code returned in querystring of callback url (or refresh_token if refreshing) (required if is_refresh=false)
                      redirect_uri: redirect_uri from authorization request (required if is_refresh=false)
                      is_refresh: boolean - whether this is a token refresh (optional - default: false)
                      refresh_token: string - refresh token (required if is_refresh=true)
                      access_token: string - access token (required if is_refresh=true)
      
                  callback: function - function(err, return_obj){console.log(return_obj.access_token);} (optional - may use returned promise instead)
              
                  returns a promise whose resolution value is an object with the following properties
                      access_token: string - currently valid access token
                      refresh_token: string - token that may be used to refresh access token
                      expiration: date - time at which access token needs to be refreshed
      */

      var deferred, https_opts, post_data, post_obj, proto_obj, rejection, return_obj;
      deferred = q.defer();
      if ((!(args.code != null)) && !args.is_refresh) {
        rejection = "Authorization code not provided";
      }
      if ((!_code_regex.test(args.code)) && !args.is_refresh) {
        rejection = "Invalid authorization code";
      }
      if ((!(args.redirect_uri != null)) && !args.is_refresh) {
        rejection = "Redirect URI not provided";
      }
      if ((!(args.refresh_token != null)) && args.is_refresh === true) {
        rejection = "Refresh token not provided";
      }
      if ((!(args.access_token != null)) && args.is_refresh === true) {
        rejection = "Access token not provided";
      }
      if ((rejection != null ? rejection.length : void 0) > 0) {
        if (callback != null) {
          callback(new Error(rejection));
        }
        deferred.reject(new Error(rejection));
        return deferred.promise;
      }
      return_obj = {};
      post_obj = {
        grant_type: args.is_refresh === true ? "refresh_token" : "authorization_code",
        client_id: this._config.client_id,
        client_secret: this._config.client_secret
      };
      https_opts = {
        hostname: this._config.test ? _test_hostname : this._config.hostname,
        port: this._config.test ? _test_port : void 0,
        path: _oauth_access_path,
        method: "POST",
        rejectUnauthorized: true,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
        }
      };
      if (args.is_refresh === true) {
        post_obj.refresh_token = args.refresh_token;
        https_opts.headers["Authorization"] = "Bearer " + args.access_token;
      } else {
        post_obj.code = args.code;
        post_obj.redirect_uri = args.redirect_uri;
      }
      post_data = querystring.stringify(post_obj);
      https_opts.headers["Content-Length"] = post_data.length;
      proto_obj = this._config.test ? http : https;
      _http_req(https_opts, proto_obj, post_data, "utf8").then(function(res_obj) {
        return deferred.resolve({
          access_token: res_obj.access_token,
          refresh_token: res_obj.refresh_token,
          expiration: new Date(Date.now() + res_obj.expires_in * 1000)
        });
      }).fail(function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    return PersonalApp;

  })();

  PersonalClient = (function() {
    /*
        Client for making calls to personal api
    */

    function PersonalClient(access_options) {
      this.access_options = access_options;
      /*
              PersonalClient constructor
      
                  access_options:
                      client_id: string
                      client_secret: string
                      client_password: string - if you have changed your client password, provide it (optional)
                      access_token: string - access token from oauth
                      refresh_token: string - refresh token from oauth
                      expiration: date - time at which access token expires
                      sandbox: boolean - Whether to use api-sandbox (default: false)
      */

      this.access_options.hostname = "" + (this.access_options.sandbox === true ? 'api-sandbox' : 'api') + ".personal.com";
      this.access_options.expiration = new Date(this.access_options.expiration);
      this._reg_events = {
        refresh_token: []
      };
    }

    PersonalClient.prototype.bind = function(event_name, callback) {
      /*
              Register a callback to run when certain events happen
      
                  event_name: string - Name of events
                  callback: string - function(data){}
      
              Valid events and data:
                  "refresh_token": Called when token is refreshed.  Data is:
                      access_token: access token
                      refresh_token: refresh_token
                      expiration: Date of expiration
      */
      if ((this._reg_events[event_name] != null) && typeof callback === 'function') {
        this._reg_events[event_name].push(callback);
      }
      return true;
    };

    PersonalClient.prototype._fire_event = function(event_name, data) {
      var callback, _i, _len, _ref, _results;
      if (this._reg_events[event_name] != null) {
        _ref = this._reg_events[event_name];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback(data));
        }
        return _results;
      }
    };

    PersonalClient.prototype.refresh = function(callback) {
      /*
              Performs a refresh on the access token.  Generally PersonalClient will take care of this for you, but this is provided in case manual refresh is desired
                  
                  callback: function - form of function(error){}, called when refresh is complete.  error is undefined on success (optional)
      
                  returns a promise object
      */

      var app, deferred,
        _this = this;
      deferred = q.defer();
      app = new PersonalApp(this.access_options);
      app.get_access_token_auth({
        refresh_token: this.access_options.refresh_token,
        access_token: this.access_options.access_token,
        is_refresh: true
      }).then(function(data) {
        var key, val;
        try {
          for (key in data) {
            if (!__hasProp.call(data, key)) continue;
            val = data[key];
            _this.access_options[key] = val;
          }
          _this.access_options.expiration = new Date(_this.access_options.expiration);
          _this._fire_event("refresh_token", _this.access_options);
          return deferred.resolve(data);
        } catch (e) {
          return deferred.reject(e);
        }
      }, function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    PersonalClient.prototype.request = function(options, callback) {
      /*
              send request to the Personal API
      
                  options: 
                      path: string - everything after "/api/v1" in the path (required)
                      method: string - "GET" "PUT" "POST" or "DELETE" (required)
                      data: object - javascript object to send (optional)
                  callback: function(err, data){} (optional)
      
                  return a promise containing the parsed object returned from the server
      */

      var deferred, do_request,
        _this = this;
      deferred = q.defer();
      do_request = function(options) {
        var https_opts, proto_obj;
        https_opts = {
          hostname: _this.access_options.test ? _test_hostname : _this.access_options.hostname,
          port: _this.access_options.test ? _test_port : void 0,
          path: "" + _api_path_prefix + "/" + (options.path.replace("#", "%23")) + "?client_id=" + _this.access_options.client_id,
          method: options.method,
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + _this.access_options.access_token,
            "Secure-Password": _this.access_options.client_password || _this.access_options.client_secret
          }
        };
        proto_obj = _this.access_options.test ? http : https;
        return _http_req(https_opts, proto_obj, JSON.stringify(options.data)).then(function(res_obj) {
          return deferred.resolve(res_obj);
        }).fail(function(err) {
          return deferred.reject(err);
        });
      };
      if (this.access_options.expiration < Date.now()) {
        this.refresh().then(function() {
          return do_request(options);
        }, function(err) {
          return deferred.reject(err);
        });
      } else {
        do_request(options);
      }
      return deferred.promise;
    };

    PersonalClient.prototype.upload_file = function(gem_id, filename, buf) {
      var deferred, do_request,
        _this = this;
      deferred = q.defer();
      do_request = function() {
        var https_opts, proto_obj;
        try {
          https_opts = {
            hostname: _this.access_options.test ? _test_hostname : _this.access_options.hostname,
            port: _this.access_options.test ? _test_port : void 0,
            path: "/file?client_id=" + _this.access_options.client_id + "&files[]=" + (encodeURIComponent(filename)) + "&gem_id=" + (encodeURIComponent(gem_id)),
            method: "POST",
            headers: {
              "Content-Type": mime.lookup(filename),
              "Content-Length": buf.toString('hex').length / 2,
              "Authorization": "Bearer " + _this.access_options.access_token,
              "Secure-Password": _this.access_options.client_password || _this.access_options.client_secret
            }
          };
          proto_obj = _this.access_options.test ? http : https;
          return _http_req(https_opts, proto_obj, buf).then(function(res_obj) {
            return deferred.resolve(res_obj);
          }).fail(function(err) {
            return deferred.reject(err);
          });
        } catch (err) {
          return deferred.reject(err);
        }
      };
      if (this.access_options.expiration < Date.now()) {
        this.refresh().then(function() {
          return do_request();
        }, function(err) {
          return deferred.reject(err);
        });
      } else {
        do_request();
      }
      return deferred.promise;
    };

    return PersonalClient;

  })();

  PersonalScope = (function() {
    /*
        
        Define the scope you need for authorization code OAuth flow
    */

    var _all_perms, _is_valid_permission_rule, _is_valid_template_id, _re_temp_id;

    _all_perms = ['read', 'write', 'create', 'grant'];

    _re_temp_id = /^[0-9]{4}$/;

    _re_temp_id.compile(_re_temp_id);

    _is_valid_template_id = function(temp_id_str) {
      return _re_temp_id.test(temp_id_str);
    };

    _is_valid_permission_rule = function(perm, resource) {
      if (_is_valid_template_id(resource) && (__indexOf.call(_all_perms, perm) >= 0)) {
        return true;
      }
      switch (resource) {
        case 'contacts':
        case 'messages':
          if (perm === 'read' || perm === 'write') {
            return true;
          }
          break;
        case 'access':
          if (perm === 'read') {
            return true;
          }
          break;
        default:
          return false;
      }
    };

    function PersonalScope(args) {
      /*
              For literal scope (e.g., "read_0135,write_0136"), provide args.literal
      
              For cartesian product scope (e.g.,, (read,write)x(0135,0136)), provide args.permission and args.resources
      
                  args:
                      permissions: array of strings for permissions. Subset of ['read', 'write', 'create', 'grant'] (optional)
                      resources: array of strings for resources to request, e.g. ['contacts','message','access','<4 digit template id>']
                      literal: Either string in proper scope format (e.g., "read_0135,write_0135") or array of objects (e.g., [{read: '0135'},{write: '0136'}])"
      */

      var perm, _i, _len;
      this._scope = {};
      for (_i = 0, _len = _all_perms.length; _i < _len; _i++) {
        perm = _all_perms[_i];
        this._scope[perm] = [];
      }
      this.add_perms_cprod(args);
      this.add_perms_simple(args.literal);
    }

    PersonalScope.prototype.add_permission_str = function(permission_string) {
      /*
              Adds one rule to permission scope by string
      
                  permission_string: String representation of rule (e.g., "read_0135")
      
                  returns true upon success, false otherwise
      */

      var name, resource, _ref;
      _ref = permission_string.split("_"), name = _ref[0], resource = _ref[1];
      return this.add_permission(name, resource);
    };

    PersonalScope.prototype.add_permission = function(name, resource) {
      /*
              Adds one rule to permission scope by name and resource
      
                  rule: Either string representation of rule (e.g., "read_0135") or object representation (e.g., {read: '0135'})
      
                  returns true upon success, false otherwise
      */
      if (_is_valid_permission_rule(name, resource)) {
        this._scope[name].push(resource);
        return true;
      }
      return false;
    };

    PersonalScope.prototype.add_perms_simple = function(rules) {
      /*
              For literal scope (e.g., "read_0135,write_0136"), provide args.literal
              
                  rules: Either string in proper scope format (e.g., "read_0135,write_0135") or array of objects (e.g., [{read: '0135'},{write: '0136'}])"
              
                  returns true if all permissions were successfully added, false if any permissions were invalid
      */

      var perm, res, rule, to_return, _i, _j, _len, _len1, _ref;
      to_return = true;
      if (Array.isArray(rules)) {
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          for (perm in rule) {
            res = rule[perm];
            if (!this.add_permission(perm, res)) {
              to_return = false;
            }
          }
        }
      } else if (typeof rules === "string") {
        _ref = rules.split(",");
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          rule = _ref[_j];
          if (!this.add_permission_str(rule)) {
            to_return = false;
          }
        }
      } else {
        to_return = false;
      }
      return to_return;
    };

    PersonalScope.prototype.add_perms_cprod = function(args) {
      /*
              Add cartesian product scope (e.g.,, (read,write)x(0135,0136))
              
                  args:
                      permissions: array of strings for permissions. Subset of ['read', 'write', 'create', 'grant']
                      resources: array of strings for resources to request, e.g. ['contacts','message','access','<4 digit template id>']
              
                  returns true if all permissions were successfully added, false if any permissions were invalid
              
              Example:
           
                  pscope.add_perms_cprod({permissions: ['read','write'], resources: ['0135','contacts']})
                  pscope.to_s() //"read_0135,read_contacts,write_0135,write_contacts"
      */

      var perm, res, to_return, _i, _j, _len, _len1, _ref, _ref1;
      to_return = true;
      if ((args.permissions != null) && Array.isArray(args.permissions) && (args.resources != null) && Array.isArray(args.permissions)) {
        _ref = args.permissions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          perm = _ref[_i];
          _ref1 = args.resources;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            res = _ref1[_j];
            if (_is_valid_permission_rule(perm, res)) {
              this._scope[perm].push(res);
            } else {
              to_return = false;
            }
          }
        }
      }
      return to_return;
    };

    PersonalScope.prototype.to_a = function() {
      /*
              Returnss the permissions as an array of strings.  Each string is suitable for use in the OAuth flow
      */

      var perm, temp, temps, to_return, _i, _len, _ref;
      to_return = [];
      _ref = this._scope;
      for (perm in _ref) {
        temps = _ref[perm];
        for (_i = 0, _len = temps.length; _i < _len; _i++) {
          temp = temps[_i];
          to_return.push("" + perm + "_" + temp);
        }
      }
      return to_return;
    };

    PersonalScope.prototype.asArray = function() {
      /*
              Returns the permissions as an array of strings.  Each string is suitable for use in the OAuth flow
      */
      return this.to_a();
    };

    PersonalScope.prototype.to_s = function() {
      /*
              Returns the permissions as a string in the format required for the Personal OAuth flow
      */
      return this.to_a().join();
    };

    PersonalScope.prototype.toString = function() {
      /*
              Returns the permissions as a string in the format required for the Personal OAuth flow
      */
      return this.to_s();
    };

    return PersonalScope;

  })();

  connect_curr_req_url = (function() {
    var ret_val, _url;
    _url = "init_val";
    return ret_val = {
      get: function() {
        return _url;
      },
      set: function(new_url) {
        return _url = new_url;
      }
    };
  })();

  PersonalConnectOptions = function(options) {
    /*
        Add all options to the connect/express options for the Personal library
        
            options:
               client_id: (required)
               client_secret: (required)
               scope: (required)
               update: boolean - (optional - default: true)
               sandbox: boolean - true to use sandbox, false otherwise (optional - default: false)
               callback_uri: string - override dynamic callback uri with something static (optional - default: dynamically created)
    
            returns its full options object
    */

    var k, key, ret, v, val;
    for (key in options) {
      if (!__hasProp.call(options, key)) continue;
      val = options[key];
      PersonalConnectOptions[key] = val;
    }
    ret = {};
    for (k in PersonalConnectOptions) {
      if (!__hasProp.call(PersonalConnectOptions, k)) continue;
      v = PersonalConnectOptions[k];
      ret[k] = v;
    }
    return ret;
  };

  PersonalConnectOptions({
    update: true,
    sandbox: false
  });

  PersonalHelpers = function(app) {
    /*
        Provides helpers for Express views
    
        To use:
    
            express = require("express");
            personal = require("personal");
            app = express();
            personal.Helpers(app);
    
        Helpers:
    
            auth_req_url() - provides the authorization request URL for starting the OAuth flow
    */
    return app.locals({
      auth_req_url: function() {
        return connect_curr_req_url.get();
      }
    });
  };

  PersonalMiddleware = function(req, res, next) {
    /*
        Connect middleware for using the Personal API
    
        To use (connect):
            
            example
    
        To use (express):
            
            express = require("express");
            personal = require("node-personal");
            personal.Options({<see PersonalConnectOptions>});
            app = express()
            app.configure(function(){
                //various configuration
                express.use(express.session(<config>));
                express.use(personal.Middleware);
            })
    
        req.session.personal.req_url will now have the appropriate URL for sending users to the authorization page
    
        Once users return from the authorization page, req.personal.client will be a working PersonalClient
    */

    var app, auth_req_obj, new_redir_uri, promise, sess;
    req.personal = {
      logout: function() {
        var _ref;
        return (_ref = req.session) != null ? _ref.personal = {
          logged_in: false
        } : void 0;
      }
    };
    if (!(req.session != null)) {
      return next(new Error("session middleware not loaded"));
    }
    if (!(req.session.personal != null)) {
      req.session.personal = {};
    }
    sess = req.session.personal;
    if ((sess.access_token != null) && (sess.refresh_token != null) && (sess.expiration != null)) {
      req.personal.logged_in = true;
      req.personal.client = new PersonalClient({
        client_id: PersonalConnectOptions.client_id,
        client_secret: PersonalConnectOptions.client_secret,
        access_token: sess.access_token,
        refresh_token: sess.refresh_token,
        expiration: sess.expiration,
        redirect_uri: sess.redirect_uri,
        sandbox: PersonalConnectOptions.sandbox
      });
      return next();
    }
    app = new PersonalApp(PersonalConnectOptions({}));
    if ((req.query.code != null) && (req.query.state != null) && (req.query.personal != null)) {
      if ((sess.state != null) && sess.state === req.query.state && (sess.redirect_uri != null)) {
        promise = app.get_access_token_auth({
          code: req.query.code,
          state: req.query.state,
          redirect_uri: sess.redirect_uri
        });
        delete sess.state;
        promise.then(function(access_obj) {
          var k, key, new_q, v, val, _ref;
          for (key in access_obj) {
            if (!__hasProp.call(access_obj, key)) continue;
            val = access_obj[key];
            sess[key] = val;
          }
          req.personal.client = new PersonalClient({
            client_id: PersonalConnectOptions.client_id,
            client_secret: PersonalConnectOptions.client_secret,
            access_token: sess.access_token,
            refresh_token: sess.refresh_token,
            expiration: sess.expiration,
            redirect_uri: sess.redirect_uri,
            sandbox: PersonalConnectOptions.sandbox
          });
          req.personal.logged_in = true;
          new_q = {};
          _ref = req.query;
          for (k in _ref) {
            if (!__hasProp.call(_ref, k)) continue;
            v = _ref[k];
            if (k !== "code" && k !== "state" && k !== "personal") {
              new_q[k] = v;
            }
          }
          return res.redirect("" + req.path + (querystring.stringify(new_q)));
        }, function(err) {
          return next(err);
        });
        return;
      } else {
        delete sess.state;
        delete sess.redirect_uri;
      }
    }
    if ((!(sess.state != null)) || (!(sess.redirect_uri != null))) {
      if (PersonalConnectOptions.callback_uri != null) {
        new_redir_uri = url.parse(PersonalConnectOptions.callback_uri, true);
      } else {
        new_redir_uri = url.parse("" + req.protocol + "://" + req.headers.host + req.url, true);
      }
      new_redir_uri.search = "";
      delete new_redir_uri.query.code;
      new_redir_uri.query.personal = true;
      auth_req_obj = app.get_auth_request_url({
        scope: PersonalConnectOptions.scope,
        update: PersonalConnectOptions.update,
        sandbox: PersonalConnectOptions.sandbox,
        redirect_uri: url.format(new_redir_uri)
      });
      connect_curr_req_url.set(auth_req_obj.url);
      sess.req_url = auth_req_obj.url;
      sess.state = auth_req_obj.state;
      sess.redirect_uri = auth_req_obj.redirect_uri;
    } else {
      connect_curr_req_url.set(sess.req_url);
    }
    return next();
  };

  exports.Client = PersonalClient;

  exports.Options = PersonalConnectOptions;

  exports.Helpers = PersonalHelpers;

  exports.Middleware = PersonalMiddleware;

  exports.App = PersonalApp;

  exports.Scope = PersonalScope;

}).call(this);
